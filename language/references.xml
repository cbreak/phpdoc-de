 <chapter id="language.references">
  <title>Referenzen in PHP</title>

  <sect1 id="language.references.whatare">
   <title>Was Referenzen sind</title>
   <simpara>  
    Referenzen sind in PHP ein Mechanismus um verschiedene Namen
    für den gleichen Inhalt von Variablen zu ermöglichen. Sie sind nicht
    mit Zeigern in C zu vergleichen, sondern Aliasdefinitionen für
    die Symboltabelle. PHP unterscheidet zwischen Variablenname
    und Variableninhalt, wobei der gleiche Variableninhalt
    unterschiedliche Namen besitzen kann. Der bestmögliche Vergleich
    ist der mit Dateinamen und Dateien im Dateisystem von Unix - 
    Variablennamen sind Verzeichniseinträge, während der 
    Variableninhalt die eigentliche Datei darstellt. Referenzen
    können nun als Hardlinks im Dateisystem verstanden werden.
   </simpara>
  </sect1>

  <sect1 id="language.references.whatdo">
   <title>Was Referenzen leisten</title>
   <para>
    PHP Referenzen erlauben es, zwei Variablennamen sich auf den
    gleichen Variableninhalt beziehen zu lassen. Das heisst im
    folgenden Beispiel, dass sich <varname>$a</varname> und
    <varname>$b</varname> auf dieselbe Variable beziehen:

    <informalexample>
     <programlisting role="php">
$a =&amp; $b 
     </programlisting>
    </informalexample>

    <note>
     <para>
      <varname>$a</varname> und <varname>$b</varname> sind hier
      gleichwertig, und <varname>$a</varname> ist nicht nur ein
      Zeiger auf <varname>$b</varname> oder umgekehrt, sondern
      <varname>$a</varname> und <varname>$b</varname> zeigen auf
      den selben Inhalt.
     </para>
    </note>
   </para>
   <para>
    Eine weitere Einsatzmöglichkeit von Referenzen ist die Übergabe 
    von Parametern an eine Funktion mit pass-by-reference. Hierbei 
    beziehen sich der lokale Variablenname als auch der Variablenname 
    der aufrufenden Instanz auf denselben Variableninhalt:
    <informalexample>
     <programlisting role="php">
function foo (&amp;$var) {
    $var++;
}

$a=5;
foo ($a);
     </programlisting>
    </informalexample>
    Nach der Ausführung hat <varname>$a</varname> den Wert 6, da sich 
    in der Funktion <varname>foo</varname> der Variablenname <varname>$var</varname> 
    auf denselben Variableninhalt bezieht wie <varname>$a</varname> 
    in der aufrufenden Instanz (hier das Hauptprogramm).
   </para>
   <simpara>
    Daneben besteht die Möglichkeit aus Funktionen heraus Werte mit 
    <link linkend="language.references.return">return by-reference</link> 
    zurückzugeben.
   </simpara>
  </sect1>

  <sect1 id="language.references.arent">
   <title>Was Referenzen nicht sind</title>
   <para>
    Wie bereits gesagt: Referenzen sind keine Zeiger. Das bedeutet, 
    der folgende Code tut nicht, was zum Beispiel ein C Programmierer 
    erwarten würde:
    <informalexample>
     <programlisting role="php">
function foo (&amp;$var) {
    $var =&amp; $GLOBALS["baz"];
}
foo($bar); 
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Folgendes wird passieren: <varname>$var</varname> in foo wird zun&auml;chst 
    an  <varname>$bar</varname> aus der aufrufenden Instanz, dann 
    aber an <varname>$GLOBALS["baz"]</varname>, gebunden.
    Es gibt keine M&ouml;glichkeit, <varname>$bar</varname> aus der aufrufenden 
    Instanz mittels Referenz-Mechanismen an etwas anderes zu binden, da 
    <varname>$bar</varname> in der Funktion foo nicht zur Verf&uuml;gung steht 
    (<varname>$bar</varname> wird durch <varname>$var</varname> repr&auml;sentiert; 
    <varname>$var</varname> verf&uuml;gt nur &uuml;ber Variableninhalt, besitzt 
    aber keinen name-to-value Eintrag in der Symboltabelle der aufrufenden 
    Instanz).
   </simpara>
  </sect1>

  <sect1 id="language.references.return">
   <title>Referenzen zurückgeben</title>
   <para>
    Returning by-refernce it is useful when you want to use function
    to find variable which should be bound to. When returning
    references, use this syntax:
    <informalexample>
     <programlisting role="php">
function &amp;find_var ($param) {
    ...code...
    return $found_var;
}

$foo =&amp; find_var ($bar);
$foo->x = 2; 
     </programlisting>
    </informalexample>
    In this example, property of the object returned by the
    <varname>find_var</varname> function would be set, not of the
    copy, as it would be without using reference syntax.
   </para>
   <note>
    <simpara>
     Unlike parameter passing, here you have to use
     <literal>&amp;</literal> in both places - to indicate that you
     return by-reference, not a copy as usual, and to indicate than
     reference binding and not usual assignment should be done for
     <varname>$foo</varname>.
    </simpara>
   </note>
  </sect1>

  <sect1 id="language.references.unset">
   <title>Referenzen aufheben</title>
   <para>
    When you unset the reference, you just break the binding between
    variable name and variable content. This does not mean that
    variable content will be destroyed. For example:
    <informalexample>
     <programlisting role="php">
$a = 1;
$b =&amp; $a;
unset ($a); 
     </programlisting>
    </informalexample>
    won't unset <varname>$b</varname>, just <varname>$a</varname>. 
   </para>
   <simpara>
    Again, it might be useful to think about this as analogous to Unix
    <command>unlink</command> call.
   </simpara>
  </sect1>

  <sect1 id="language.references.spot">
   <title>Referenzen entdecken</title>
   <simpara>
    Viele Sprachelemente von PHP sind intern mit der Benutzung von Referenzen 
    implementiert, daher gilt alles bisher gesagte auch f&uuml;r diese 
    Konstrukte:
   </simpara>

   <sect2 id="references.global">
    <title><literal>global</literal> References</title>
    <para>
     Die Verwendung von <command>global $var</command> erzeugt im aktuellen 
     Scope eine Referenz auf die globale Variable <varname>$var</varname>, 
     sie ist also &auml;quivalent zu folgendem:
     <informalexample>
      <programlisting role="php">
$var =&amp; $GLOBALS["var"];
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Dies hat zur Folge, daß das Anwenden von unset() auf <varname>$var</varname> 
     keinen Einfluß auf die globale Variable hat.
    </simpara>
   </sect2>

   <sect2 id="references.this">
    <title><literal>$this</literal></title>
    <simpara>
     In einer Objektmethode ist <varname>$this</varname> immer eine Referenz 
     auf die aufrufende Objektinstanz.
    </simpara>
   </sect2>
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
